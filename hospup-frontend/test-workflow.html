<!DOCTYPE html>
<html>
<head>
    <title>Test Workflow Complet</title>
</head>
<body>
    <h1>Test Workflow Complet - Capture + Upload AWS</h1>

    <!-- Simulation de l'aper√ßu video -->
    <div id="preview" style="width: 300px; height: 533px; background: black; position: relative; border: 2px solid white;">
        <video style="width: 100%; height: 100%; object-fit: cover; opacity: 1;"
               src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
               muted autoplay loop class="opacity-100"></video>

        <!-- Text overlay simulation -->
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    color: white; font-size: 24px; font-family: Arial; text-align: center;">
            Test Text Overlay
        </div>
    </div>

    <br><br>

    <button onclick="testCompleteWorkflow()">üöÄ Test Workflow Complet (3s)</button>
    <div id="status"></div>
    <div id="result"></div>

    <script>
        // Copie exacte du SimpleVideoCapture
        class TestSimpleVideoCapture {
            static async capturePreviewToVideo(previewElement, durationMs) {
                try {
                    console.log(`üöÄ Starting CANVAS video capture: ${durationMs}ms`);

                    // Format Full HD vertical (9:16)
                    const canvas = document.createElement('canvas');
                    canvas.width = 1080;  // Largeur vertical
                    canvas.height = 1920; // Hauteur vertical (9:16)
                    const ctx = canvas.getContext('2d');

                    console.log(`üìê Canvas: ${canvas.width}x${canvas.height}px (Full HD Vertical 9:16)`);

                    // Remplir le fond en noir
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Fonction pour dessiner une frame
                    const drawFrame = () => {
                        // Effacer le canvas
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Trouver la vid√©o active (celle avec opacity-100)
                        const videos = previewElement.querySelectorAll('video');
                        const activeVideo = Array.from(videos).find(video =>
                            video.classList.contains('opacity-100') && video.readyState >= 2
                        );

                        if (activeVideo) {
                            // Dessiner la vid√©o active sur le canvas
                            try {
                                ctx.drawImage(activeVideo, 0, 0, canvas.width, canvas.height);
                            } catch (e) {
                                console.warn('Erreur dessin vid√©o, continuons:', e);
                            }
                        }

                        // Dessiner les overlays de texte par dessus
                        const textOverlays = previewElement.querySelectorAll('[style*="position: absolute"]');
                        textOverlays.forEach(overlay => {
                            const style = window.getComputedStyle(overlay);
                            const rect = overlay.getBoundingClientRect();
                            const containerRect = previewElement.getBoundingClientRect();

                            // Calculer la position relative dans le canvas
                            const x = ((rect.left - containerRect.left) / containerRect.width) * canvas.width;
                            const y = ((rect.top - containerRect.top) / containerRect.height) * canvas.height;

                            // Dessiner le texte
                            if (overlay.textContent) {
                                ctx.fillStyle = style.color || '#ffffff';
                                ctx.font = `${style.fontSize || '16px'} ${style.fontFamily || 'Arial'}`;
                                ctx.textAlign = style.textAlign || 'left';
                                ctx.fillText(overlay.textContent, x, y + 20); // +20 pour l'offset baseline
                            }
                        });
                    };

                    // D√©marrer la capture stream
                    const stream = canvas.captureStream(30); // 30 FPS
                    console.log('‚úÖ Canvas stream created');

                    // Animation loop pour dessiner les frames
                    let animationId;
                    const animate = () => {
                        drawFrame();
                        animationId = requestAnimationFrame(animate);
                    };
                    animate();

                    // MediaRecorder pour capturer le stream
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 2500000
                    });

                    const chunks = [];

                    return new Promise((resolve, reject) => {
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                                console.log(`üì¶ Video chunk: ${event.data.size} bytes`);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            console.log('üõë Recording stopped');
                            cancelAnimationFrame(animationId);

                            const blob = new Blob(chunks, { type: 'video/webm' });
                            console.log(`‚úÖ Final video: ${blob.size} bytes`);

                            if (blob.size === 0) {
                                reject(new Error('Generated video is empty (0 bytes)'));
                            } else {
                                resolve(blob);
                            }
                        };

                        mediaRecorder.onerror = (error) => {
                            console.error('‚ùå MediaRecorder error:', error);
                            cancelAnimationFrame(animationId);
                            reject(error);
                        };

                        // D√©marrer l'enregistrement
                        console.log(`üé¨ Starting recording for ${durationMs}ms...`);
                        mediaRecorder.start(250);

                        // Arr√™ter apr√®s la dur√©e demand√©e
                        setTimeout(() => {
                            console.log('‚è∞ Duration reached, stopping recording...');
                            if (mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        }, durationMs);
                    });

                } catch (error) {
                    console.error('‚ùå Canvas capture failed:', error);
                    throw error;
                }
            }

            static async uploadToS3(blob, filename) {
                const formData = new FormData();
                formData.append('file', blob, filename);

                try {
                    console.log('‚òÅÔ∏è Uploading to AWS S3...');
                    const response = await fetch('/api/upload-video', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ S3 upload success:', data.url);
                    return data.url;

                } catch (error) {
                    console.error('‚ùå S3 upload failed:', error);
                    throw error;
                }
            }
        }

        async function testCompleteWorkflow() {
            const statusDiv = document.getElementById('status');
            const resultDiv = document.getElementById('result');

            try {
                statusDiv.innerHTML = '<p>üöÄ D√©marrage du test complet...</p>';

                const previewElement = document.getElementById('preview');
                const durationMs = 3000; // 3 secondes

                // 1. Capture vid√©o
                statusDiv.innerHTML = '<p>üé¨ Capture de la vid√©o...</p>';
                const blob = await TestSimpleVideoCapture.capturePreviewToVideo(previewElement, durationMs);

                statusDiv.innerHTML = `<p>‚úÖ Vid√©o captur√©e: ${blob.size} bytes</p>`;

                // 2. Upload AWS S3
                statusDiv.innerHTML = `<p>‚òÅÔ∏è Upload vers AWS S3...</p>`;
                const filename = `test-workflow-${Date.now()}.webm`;
                const s3Url = await TestSimpleVideoCapture.uploadToS3(blob, filename);

                // 3. Succ√®s !
                statusDiv.innerHTML = `<p style="color: green;">üéâ WORKFLOW COMPLET R√âUSSI !</p>`;
                resultDiv.innerHTML = `
                    <h3>R√©sultats:</h3>
                    <p><strong>Taille vid√©o:</strong> ${blob.size} bytes</p>
                    <p><strong>Dur√©e capture:</strong> ${durationMs}ms</p>
                    <p><strong>URL AWS S3:</strong> <a href="${s3Url}" target="_blank">${s3Url}</a></p>
                    <p><strong>Format:</strong> 1080x1920px (9:16)</p>
                `;

            } catch (error) {
                console.error('‚ùå Workflow failed:', error);
                statusDiv.innerHTML = `<p style="color: red;">‚ùå Erreur: ${error.message}</p>`;
                resultDiv.innerHTML = '';
            }
        }
    </script>
</body>
</html>